# Redis Streams 직접 구현하며 배우기

## 📋 Stage 목록

| Stage | 제목 | 난이도 |
|-------|------|--------|
| 1 | TYPE 명령어 구현하기 | ⬤○○ 쉬움 |
| 2 | 스트림 생성하기 | ⬤⬤○ 보통 |
| 3 | 엔트리 ID 유효성 검증 | ⬤○○ 쉬움 |
| 4 | 부분 자동 생성 ID | ⬤⬤○ 보통 |
| **5** | **완전 자동 생성 ID** | ⬤⬤○ 보통 |
| 6 | 스트림에서 엔트리 조회하기 | ⬤⬤○ 보통 |
| 7 | `-` 를 사용한 쿼리 | ⬤○○ 쉬움 |
| 8 | `+` 를 사용한 쿼리 | ⬤○○ 쉬움 |
| 9 | XREAD로 단일 스트림 조회 | ⬤⬤○ 보통 |
| 10 | XREAD로 다중 스트림 조회 | ⬤⬤○ 보통 |
| 11 | 블로킹 읽기 | ⬤⬤⬤ 어려움 |
| 12 | 타임아웃 없는 블로킹 읽기 | ⬤⬤○ 보통 |
| 13 | `$` 를 사용한 블로킹 읽기 | ⬤○○ 쉬움 |

---

## Stage 5: 완전 자동 생성 ID

### 🎯 목표

ID를 `*`로 지정하면 **타임스탬프와 시퀀스 번호 모두 자동 생성**되도록 `XADD` 명령어를 확장합니다.

---

### 📚 배경 지식

#### 완전 자동 생성 ID

실제 애플리케이션에서는 대부분 ID를 `*`로 지정하여 Redis가 자동으로 생성하도록 합니다:

```
XADD mystream * temperature 36 humidity 95
              ↑
        타임스탬프-시퀀스 모두 자동
```

#### ID 자동 생성 규칙

1. **타임스탬프**: 현재 시스템 시간 (밀리초)
2. **시퀀스 번호**: 
   - 마지막 엔트리와 타임스탬프가 같으면: `마지막 시퀀스 + 1`
   - 타임스탬프가 다르면: `0`

#### 시간 역행 방지

시스템 시간이 마지막 엔트리의 타임스탬프보다 과거일 수 있습니다 (NTP 동기화 등). 이 경우:
- 타임스탬프는 **마지막 엔트리의 타임스탬프를 유지**
- 시퀀스 번호만 증가

```
마지막 ID: 1000-5
현재 시간: 900ms (과거!)
생성되는 ID: 1000-6 (시간 역행 방지)
```

---

### ✅ 통과 조건

- `*`를 ID로 사용하여 엔트리를 추가할 수 있어야 합니다
- 생성된 ID의 타임스탬프는 현재 시간 또는 마지막 엔트리 시간 이상이어야 합니다
- 시퀀스 번호가 올바르게 자동 생성되어야 합니다

---

### 💡 힌트

```kotlin
fun generateFullId(lastId: StreamId?): StreamId {
    val currentTime = System.currentTimeMillis()
    
    if (lastId == null) {
        // 빈 스트림
        return StreamId(currentTime, 0)
    }
    
    return if (currentTime > lastId.milliseconds) {
        // 정상: 현재 시간이 더 큼
        StreamId(currentTime, 0)
    } else {
        // 시간 역행 방지: 마지막 타임스탬프 유지, 시퀀스만 증가
        StreamId(lastId.milliseconds, lastId.sequence + 1)
    }
}

fun handleXAdd(args: List<String>): String {
    val key = args[0]
    val idArg = args[1]
    
    val id = when {
        idArg == "*" -> {
            // 완전 자동 생성
            generateFullId(getLastEntryId(key))
        }
        idArg.endsWith("-*") -> {
            // 부분 자동 생성 (Stage 4)
            // ...
        }
        else -> {
            // 명시적 ID (Stage 2)
            StreamId.parse(idArg)
        }
    }
    
    // 엔트리 추가 및 응답...
}
```

---

### 🧪 테스트 방법

```bash
redis-cli

# 자동 생성 ID로 엔트리 추가
127.0.0.1:6379> XADD mystream * temperature 36
"1609459200000-0"    # 실제 출력은 현재 시간에 따라 다름

127.0.0.1:6379> XADD mystream * temperature 37
"1609459200001-0"    # 시간이 지나서 새 타임스탬프

# 빠르게 여러 개 추가하면 시퀀스 증가
127.0.0.1:6379> XADD mystream * a 1
"1609459200100-0"
127.0.0.1:6379> XADD mystream * b 2
"1609459200100-1"    # 같은 밀리초 내 시퀀스 증가
127.0.0.1:6379> XADD mystream * c 3
"1609459200100-2"
```

---

### 🤔 생각해볼 점

#### 왜 시간 역행을 방지해야 할까요?

- **ID 유일성 보장**: 같은 ID가 두 번 생성되면 안 됩니다
- **순서 일관성**: 이벤트 로그에서 순서는 매우 중요합니다
- **분산 환경 대응**: NTP 동기화로 시스템 시간이 조정될 수 있습니다

#### 시퀀스 오버플로우는?

실제 Redis는 시퀀스 번호로 64비트 정수를 사용합니다. 같은 밀리초에 2^64개의 엔트리를 추가하는 것은 현실적으로 불가능합니다.

---

### ➡️ 다음 단계

Stage 6에서는 **XRANGE 명령어로 스트림의 엔트리를 조회**하는 기능을 구현합니다.
